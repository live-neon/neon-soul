# Phase 3.5: Pipeline Completion

**Date**: 2026-02-07
**Status**: âœ… Complete
**Master Plan**: [soul-bootstrap-master.md](./2026-02-07-soul-bootstrap-master.md)
**Depends on**: Phase 3 (memory ingestion pipeline)
**Blocks**: [Phase 4](./2026-02-07-phase4-openclaw-integration.md) (skill integration)
**Issue**: [Phase 4 Code Review Findings](../issues/phase4-plan-code-review-findings.md)

---

## Objective

Complete the pipeline infrastructure by resolving critical gaps identified in the Phase 4 code review. This phase bridges the gap between placeholder stages and a fully functional synthesis pipeline.

**Scope boundary**: Infrastructure and pipeline only. Commands, skill entry point, and E2E tests remain in Phase 4.

---

## Current State

**What exists**:
- Pipeline orchestrator with 8 stages defined (`pipeline.ts`)
- Source collector (`source-collector.ts`) - implemented, expects `workspacePath`
- Signal extractor (`signal-extractor.ts`) - implemented but LLM stub returns empty
- Memory walker (`memory-walker.ts`) - fully implemented
- Reflection loop (`reflection-loop.ts`) - fully implemented
- Soul generator (`soul-generator.ts`) - fully implemented
- Backup utilities (`backup.ts`) - fully implemented
- State management (`state.ts`) - fully implemented

**What's broken**:
- C-1: Path convention mismatch (pipeline passes `memoryPath`, collector expects `workspacePath`)
- C-2: Signal extractor stub returns empty array (no deterministic fallback)
- C-3: `backupCurrentSoul` is placeholder (returns context unchanged)
- I-1: Only 4/8 pipeline stages actually implemented
- I-2: No persistence layer (signals/principles/axioms not written to disk)

---

## Stage 3.5.1: Fix Path Convention (C-1)

**Goal**: Align path expectations between pipeline and source collector.

**Problem analysis**:
- `PipelineOptions.memoryPath` stores memory directory path (e.g., `~/.openclaw/workspace/memory`)
- `collectSources()` expects workspace root and appends `/memory` internally (line 142)
- Current pipeline would read `memory/memory/` - returning zero sources

**Implementation approach**:
- Option C from issue: Extract workspace from memoryPath before calling collector
- Add helper function `getWorkspacePath(memoryPath: string): string`
- Update `collectSources` stage to call `collectSources(workspacePath)` not `memoryPath`

**Files to modify**:
- `src/lib/pipeline.ts` - Update `collectSources` stage implementation

**Acceptance criteria**:
- [ ] `collectSources` stage receives correct workspace path
- [ ] Source collection returns non-empty results for valid workspace
- [ ] Path derivation handles both `/memory` suffix and `/memory/` suffix

---

## Stage 3.5.2: Implement Signal Extraction Fallback (C-2)

**Goal**: Provide deterministic signal extraction for tests and CI without LLM dependency.

**Problem analysis**:
- `callLLMForSignals()` always returns empty array
- E2E tests fail: no signals means no principles means no axioms
- `validateSoulOutput` rejects runs with zero axioms

**Implementation approach**:
- Implement pattern-based extraction using existing embedding infrastructure
- Extract signals from markdown structure (headings, lists, emphasis)
- Use semantic similarity to classify signal types
- Reserve LLM integration for production skill context (Phase 4)

**Pattern references**:
- `memory-extraction-config.ts` - has extraction prompts (reuse patterns)
- `embeddings.ts` - local embeddings via transformers.js
- `matcher.ts` - cosine similarity for classification

**Files to modify**:
- `src/lib/signal-extractor.ts` - Replace stub with pattern-based extraction

**Acceptance criteria**:
- [ ] `extractSignals()` returns non-empty array for valid markdown
- [ ] Signal types classified using embedding similarity
- [ ] Provenance chain populated (source file, line number)
- [ ] No external API dependencies (local embeddings only)

---

## Stage 3.5.3: Implement Backup Stage (C-3)

**Goal**: Wire `backupCurrentSoul` pipeline stage to existing backup utilities.

**Problem analysis**:
- `backupCurrentSoul` returns context unchanged (placeholder)
- Rollback command (Phase 4) depends on working backups
- `backup.ts` already has `backupFile()` function ready to use

**Implementation approach**:
- Check if SOUL.md exists at output path
- If exists, call `backupFile(outputPath)` from `backup.ts`
- Store backup path in `context.backupPath` for rollback reference
- Handle missing file gracefully (first run has no backup)

**Files to modify**:
- `src/lib/pipeline.ts` - Update `backupCurrentSoul` stage

**Acceptance criteria**:
- [ ] Existing SOUL.md backed up before overwrite
- [ ] Backup path stored in pipeline context
- [ ] Missing file handled gracefully (no error on first run)
- [ ] Backup directory created: `.neon-soul/backups/{timestamp}/SOUL.md`

---

## Stage 3.5.4: Wire Remaining Pipeline Stages (I-1)

**Goal**: Connect all 8 pipeline stages to real implementations.

**Stages needing work**:

1. **`checkContentThreshold`** (partial):
   - Currently: Always proceeds (TODO comment)
   - Fix: Use `state.ts` to load previous run, compare new content size
   - Call `shouldRunSynthesis()` from `state.ts`

2. **`collectSources`** (fixed in 3.5.1):
   - Wire to actual `source-collector.ts`

3. **`extractSignals`** (fixed in 3.5.2):
   - Wire to actual `signal-extractor.ts`
   - Iterate memory files, aggregate signals

4. **`reflectiveSynthesis`** (partial):
   - Currently: Uses tracker but returns empty arrays
   - Fix: Call `runReflectiveLoop()` from `reflection-loop.ts`
   - Pass extracted signals, receive principles and axioms

5. **`generateSoul`** (placeholder):
   - Currently: Sets `soulContent = ''`
   - Fix: Call `generateSoul()` from `soul-generator.ts`
   - Write to output path (respecting dry-run flag)

6. **`commitChanges`** (placeholder):
   - Currently: Sets `committed = false`
   - Fix: Call `commitSoulUpdate()` from `backup.ts`
   - Only commit if not in git repo or dry-run

**Files to modify**:
- `src/lib/pipeline.ts` - Wire all stages to implementations

**Acceptance criteria**:
- [ ] All 8 stages call real implementations
- [ ] Pipeline metrics populated from actual data
- [ ] Dry-run mode skips write stages correctly
- [ ] Progress callbacks fire at each stage

---

## Stage 3.5.5: Add Persistence Layer (I-2)

**Goal**: Persist synthesis outputs for commands to consume.

**Problem analysis**:
- `status.ts`, `trace.ts`, `audit.ts` expect data in `.neon-soul/`
- Pipeline never persists signals, principles, or axioms
- Current `audit.ts` reads from test fixtures

**Data to persist**:
```
.neon-soul/
  state.json       # Synthesis state (already exists in state.ts)
  signals.json     # Extracted signals
  principles.json  # Generated principles
  axioms.json      # Promoted axioms
```

**Implementation approach**:
- Add persistence after `reflectiveSynthesis` stage
- Use existing `saveState()` pattern from `state.ts`
- Create `saveSynthesisData()` helper for signals/principles/axioms
- Include provenance chains for audit traceability

**Files to create/modify**:
- `src/lib/persistence.ts` (NEW) - Synthesis data persistence utilities
- `src/lib/pipeline.ts` - Call persistence after synthesis

**Acceptance criteria**:
- [ ] Signals persisted to `.neon-soul/signals.json`
- [ ] Principles persisted to `.neon-soul/principles.json`
- [ ] Axioms persisted to `.neon-soul/axioms.json`
- [ ] State updated with run metrics
- [ ] Persisted data includes provenance for tracing

---

## Quality Gate: QG-Pipeline

Before marking Phase 3.5 complete:

| Metric | Target | How to Verify |
|--------|--------|---------------|
| Pipeline stages implemented | 8/8 | Code review - no TODO/placeholder in stages |
| Path convention fixed | Verified | Unit test: collectSources receives workspace path |
| Signal extraction works | Non-empty | Integration test: extract from test fixture |
| Backup stage works | Verified | Unit test: backup created before overwrite |
| Persistence layer works | 4 files | Check `.neon-soul/` contains all JSON files |
| Existing tests pass | 100% | `npm test` - all green |

**Verification commands**:
```bash
# All tests pass
npm test

# Build succeeds
npm run build

# Lint clean
npm run lint
```

---

## Deliverables

- [x] Path convention fix in `pipeline.ts`
- [x] Pattern-based signal extraction in `signal-extractor.ts`
- [x] Working backup stage in `pipeline.ts`
- [x] All 8 pipeline stages wired to implementations
- [x] New `persistence.ts` module
- [x] Updated state management

---

## Effort Estimate

| Stage | Estimate | Notes |
|-------|----------|-------|
| Stage 3.5.1: Path convention | 0.5h | Simple path derivation |
| Stage 3.5.2: Signal extraction | 2h | Pattern matching with embeddings |
| Stage 3.5.3: Backup stage | 0.5h | Wire existing backup.ts |
| Stage 3.5.4: Wire all stages | 2h | Connect 6 stages to implementations |
| Stage 3.5.5: Persistence layer | 1.5h | New module + integration |

**Total**: ~6.5 hours active work

---

## Dependencies

**Internal (from previous phases)**:
- `src/lib/source-collector.ts` - Source collection (Phase 3)
- `src/lib/memory-walker.ts` - Memory traversal (Phase 3)
- `src/lib/signal-extractor.ts` - Signal extraction base (Phase 1)
- `src/lib/reflection-loop.ts` - Iterative synthesis (Phase 3)
- `src/lib/soul-generator.ts` - SOUL.md generation (Phase 3)
- `src/lib/backup.ts` - Backup/rollback (Phase 0)
- `src/lib/state.ts` - State persistence (Phase 0)
- `src/lib/embeddings.ts` - Local embeddings (Phase 1)

**External**:
- `@xenova/transformers` - Local embedding model

---

## Cross-References

- **Issue tracking**: [Phase 4 Code Review Findings](../issues/phase4-plan-code-review-findings.md)
- **Blocked plan**: [Phase 4 OpenClaw Integration](./2026-02-07-phase4-openclaw-integration.md)
- **Master plan**: [Soul Bootstrap Master](./2026-02-07-soul-bootstrap-master.md)

---

## Notes

- This phase focuses on infrastructure - no new commands or user-facing features
- Signal extraction fallback is deterministic (embeddings-based) to enable testing
- LLM-based extraction remains for Phase 4 skill integration
- After Phase 3.5: Phase 4 can proceed with confidence that pipeline works end-to-end

---

*Phase 3.5 completes the pipeline foundation. Success means the synthesis pipeline produces actual axioms from memory files.*
